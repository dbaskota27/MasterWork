import os
import openai
import requests
import json
import pandas as pd
from concurrent.futures import ThreadPoolExecutor, as_completed
from threading import Lock
try:
    import pyttsx3
except ImportError:
    pyttsx3 = None
from gtts import gTTS
from moviepy.editor import concatenate_videoclips, AudioFileClip, VideoFileClip, vfx, TextClip, CompositeVideoClip
from moviepy.video.compositing.transitions import crossfadein
from moviepy.config import change_settings

# === CONFIGURATION ===
IMAGEMAGICK_BINARY = r"C:\\Program Files\\ImageMagick-7.1.1-Q16-HDRI\\magick.exe"
change_settings({"IMAGEMAGICK_BINARY": IMAGEMAGICK_BINARY})

openai.api_key = api_key  # Replace with your key
PEXELS_API_KEY = PEXELS_API_KEY  # Replace with your key
OUTPUT_DIR = "outputs"
os.makedirs(OUTPUT_DIR, exist_ok=True)

video_summaries = []
audio_lock = Lock()

def generate_ideas_via_prompt():
    prompt = """
Generate 3 faceless short-form video ideas for Instagram Reels in different kind of wellness niche.

Each idea should be a JSON object with:
- ID: integer
- Topic: short title (max 10 words)
- Scene Prompts: Array of 3‚Äì5 vivid, specific visual descriptions
- Text Prompt: A 200 word narration following storytelling arc
- Duration (s): Estimated time (60s)
- Title: Scroll-stopping caption (max 15 words)
- Tags: Array of 5‚Äì7 hashtags
Return a clean JSON array of 3 ideas.
"""
    print("üí¨ Requesting video ideas from ChatGPT...")
    try:
        response = openai.ChatCompletion.create(
            model="gpt-4",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.7
        )
        content = response.choices[0].message.content.strip()
        ideas = json.loads(content)
        df = pd.DataFrame(ideas)
        df.to_excel(os.path.join(OUTPUT_DIR, "video_ideas.xlsx"), index=False)
        print("‚úÖ Saved to video_ideas.xlsx")
        return df
    except Exception as e:
        print(f"‚ùå Error in OpenAI request: {e}")
        raise

def download_stock_videos_for_scenes(scene_prompts, base_name, max_results=1):
    headers = {"Authorization": PEXELS_API_KEY}
    video_paths = []
    fallback_queries = ["nature", "city", "abstract"]

    for i, prompt in enumerate(scene_prompts):
        query = prompt.split('.')[0].strip()
        print(f"üéû Searching Pexels for: {query}")
        url = f"https://api.pexels.com/videos/search?query={query}&per_page={max_results}&orientation=portrait"
        res = requests.get(url, headers=headers)

        if res.status_code != 200:
            print(f"‚ö†Ô∏è Pexels API error for '{query}': {res.status_code}")
            query = fallback_queries[i % len(fallback_queries)]
            url = f"https://api.pexels.com/videos/search?query={query}&per_page={max_results}&orientation=portrait"
            res = requests.get(url, headers=headers)

        try:
            data = res.json()
            video_url = data["videos"][0]["video_files"][0]["link"]
            video_data = requests.get(video_url).content
            video_path = os.path.join(f"{base_name}_scene_{i+1}.mp4")
            with open(video_path, "wb") as f:
                f.write(video_data)
            if os.path.getsize(video_path) > 0:
                video_paths.append(video_path)
                print(f"‚úÖ Downloaded: {video_path}")
            else:
                raise ValueError("Downloaded file is empty")
        except Exception as e:
            print(f"‚ö†Ô∏è Error downloading '{query}': {e}")

    return video_paths

def generate_audio(text, filename, target_duration):
    print("üîä Generating narration audio...")
    if pyttsx3:
        try:
            engine = pyttsx3.init()
            word_count = len(text.split())
            adjusted_rate = int((word_count / target_duration) * 60)
            engine.setProperty('rate', max(100, min(adjusted_rate, 200)))
            engine.setProperty('volume', 1.0)
            engine.save_to_file(text, filename)
            engine.runAndWait()
            print(f"‚úÖ Audio saved: {filename}")
            return filename
        except Exception as e:
            print(f"‚ö†Ô∏è pyttsx3 failed: {e}. Falling back to gTTS.")
    try:
        tts = gTTS(text=text, lang='en', tld='com', slow=False)
        tts.save(filename)
        print(f"‚úÖ Audio saved: {filename}")
        return filename
    except Exception as e:
        print(f"‚ùå Audio generation failed: {e}")
        return None

def create_video_from_clips_with_effects(video_paths, audio_path, output_path, text_prompt):
    print("üé¨ Stitching and adding effects to video clips...")
    try:
        with audio_lock:
            audio_clip = AudioFileClip(audio_path) if audio_path and os.path.exists(audio_path) else None

        standard_size = (1080, 1920)
        target_duration = 30

        video_clips = []
        for clip_path in video_paths:
            if not os.path.exists(clip_path):
                continue
            raw_clip = VideoFileClip(clip_path)
            clip_duration = min(raw_clip.duration, target_duration / len(video_paths))
            resized = raw_clip.resize(newsize=standard_size).set_duration(clip_duration)
            zoomed = resized.fx(vfx.resize, lambda t: 1 + 0.05 * t / clip_duration).fx(
                vfx.crop, width=standard_size[0], height=standard_size[1],
                x_center=standard_size[0]/2, y_center=standard_size[1]/2
            )
            text_snippet = " ".join(text_prompt.split()[:10]) + "..."
            try:
                text_clip = TextClip(
                    text_snippet, fontsize=70, color='white', font='Arial',
                    stroke_color='black', stroke_width=2
                ).set_position(('center', 'bottom')).set_duration(clip_duration).set_opacity(0.8)
                final_clip = CompositeVideoClip([zoomed, text_clip])
            except Exception:
                final_clip = zoomed
            video_clips.append(final_clip)

        if not video_clips:
            return None

        overlap = 0.5
        transitioned_clips = []
        cumulative_time = 0
        for i, clip in enumerate(video_clips):
            if i > 0:
                clip = clip.fx(crossfadein, overlap)
                cumulative_time -= overlap
            clip = clip.set_start(cumulative_time)
            cumulative_time += clip.duration
            transitioned_clips.append(clip)

        final_video = CompositeVideoClip(transitioned_clips, size=standard_size)
        total_video_duration = final_video.duration

        if audio_clip:
            narration_duration = audio_clip.duration
            if abs(narration_duration - total_video_duration) > 0.1:
                audio_clip.close()
                with audio_lock:
                    try:
                        os.remove(audio_path)
                    except PermissionError:
                        import time
                        time.sleep(1)
                        os.remove(audio_path)
                    generate_audio(text_prompt, audio_path, total_video_duration)
                    audio_clip = AudioFileClip(audio_path)

            with audio_lock:
                audio_clip = audio_clip.audio_fadein(0.5).audio_fadeout(0.5)
                final_video = final_video.set_audio(audio_clip)

        temp_audiofile = os.path.join(OUTPUT_DIR, f"temp_{os.path.basename(output_path)}_snd.mp4")
        final_video.write_videofile(
            output_path, fps=24, codec='libx264', audio_codec='aac', temp_audiofile=temp_audiofile
        )

        final_video.close()
        if audio_clip:
            audio_clip.close()
        for clip in video_clips:
            clip.close()

        for clip_path in video_paths:
            try:
                if os.path.exists(clip_path):
                    os.remove(clip_path)
                    print(f"üßπ Deleted temp clip: {clip_path}")
            except Exception as e:
                print(f"‚ö†Ô∏è Could not delete {clip_path}: {e}")

        return output_path
    except Exception as e:
        print(f"‚ùå Video creation failed: {e}")
        return None

def process_single_video(row):
    try:
        id = int(row["ID"])
        text_prompt = row["Text Prompt"]
        title = row.get("Title", f"video_{id}")
        base = os.path.join(OUTPUT_DIR, f"video_{id}")
        audio_path = f"{base}_audio.mp3"
        video_path = f"{base}.mp4"

        print(f"\nüìΩÔ∏è Processing: {title} (ID {id})")

        with audio_lock:
            generate_audio(text_prompt, audio_path, 30)

        scene_prompts = row["Scene Prompts"]
        if isinstance(scene_prompts, str):
            scene_prompts = json.loads(scene_prompts)

        video_segments = download_stock_videos_for_scenes(scene_prompts, base)
        if video_segments:
            created_path = create_video_from_clips_with_effects(video_segments, audio_path, video_path, text_prompt)
            if created_path:
                print(f"‚úÖ Created video: {created_path}")
                try:
                    clip = VideoFileClip(created_path)
                    duration = clip.duration
                    clip.close()

                    video_summaries.append({
                        "ID": id,
                        "Title": title,
                        "Final Video Path": created_path,
                        "Duration (seconds)": round(duration, 2),
                        "Tags": row.get("Tags", "[]")
                    })
                except Exception as e:
                    print(f"‚ö†Ô∏è Could not fetch duration for {created_path}: {e}")
        else:
            print(f"‚ö†Ô∏è Skipped ID {id}: No usable clips found")
    except Exception as e:
        print(f"‚ùå Error processing ID {row.get('ID')}: {e}")

def process_excel_with_effects(df, max_workers=4):
    print(f"üöÄ Starting parallel processing with {max_workers} workers...")
    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        futures = [executor.submit(process_single_video, row) for _, row in df.iterrows()]
        for future in as_completed(futures):
            try:
                future.result()
            except Exception as e:
                print(f"‚ùå Error in thread: {e}")

    if video_summaries:
        summary_df = pd.DataFrame(video_summaries)
        summary_path = os.path.join(OUTPUT_DIR, "video_summary.xlsx")
        summary_df.to_excel(summary_path, index=False)
        print(f"üìã Summary saved: {summary_path}")

def main():
    if not openai.api_key or not PEXELS_API_KEY:
        print("‚ùå Missing API keys.")
        return
    if not os.path.exists(IMAGEMAGICK_BINARY):
        print(f"‚ùå ImageMagick not found.")
        return
    try:
        df = generate_ideas_via_prompt()
        process_excel_with_effects(df)
        print("üéâ All videos created!")
    except Exception as e:
        print(f"‚ùå Main execution failed: {e}")

if __name__ == "__main__":
    main()
